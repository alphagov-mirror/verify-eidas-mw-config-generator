#!/usr/bin/env ruby

require 'erb'
require 'nokogiri'
require 'open-uri'
require 'openssl'
require 'ostruct'
require 'securerandom'
require 'yaml'

def render_erb(template, hash, output_file = nil)
  erb = File.read(File.join(__dir__, 'templates', "#{template}.erb"))
  File.open(output_file || template, 'w') do |f|
    f.print(ERB.new(erb).result(OpenStruct.new(hash).instance_eval { binding }))
  end
end

if ARGV.size < 2
  abort('Usage: generate <cfg file> <output dir>')
end

CONFIG_DEF = ARGV[0]
OUTPUT_DIR = File.expand_path(ARGV[1])

YAML.load_file(CONFIG_DEF).tap do |cfg|
  # Random password for keystores
  cfg['ks_password'] = SecureRandom.hex

  # Random password for database
  cfg['db_password'] = SecureRandom.hex

  # Grab the port -- should fallback to 443 if URL is https and explicit port omitted
  cfg['middleware_port'] = URI(cfg.fetch('middleware_url')).port

  # Fetch connector metadata
  @connector_metadata_raw = open(cfg.fetch('connector_metadata_url')).read
 
  # Extract signing cert
  connector_metadata_xml = Nokogiri::XML(@connector_metadata_raw)
  connector_metadata_xml.remove_namespaces!
  connector_metadata_x509 = connector_metadata_xml.css('EntityDescriptor Signature KeyInfo X509Data X509Certificate').text
  @connector_metadata_cert = OpenSSL::X509::Certificate.new(['-----BEGIN CERTIFICATE-----', connector_metadata_x509, '-----END CERTIFICATE-----'].join)
  puts("Connector metadata signing cert: #{@connector_metadata_cert.subject}")

  Dir.chdir(File.dirname(File.expand_path(CONFIG_DEF))) do |cwd|
    puts("Config in #{cwd}")

    # User-facing SSL keypair
    ssl_cert = OpenSSL::X509::Certificate.new(File.read(cfg.dig('ssl', 'cert')))
    ssl_key = OpenSSL::PKey.read(File.open(cfg.dig('ssl', 'key')))
    ssl_key_enc = ssl_key.export(OpenSSL::Cipher.new('AES-128-CBC'), cfg['ks_password'])
    @ssl_p12 = OpenSSL::PKCS12.create(cfg['ks_password'], 'localhost', ssl_key, ssl_cert)

    # DVCA-facing TLS keypair
    tls_cert = OpenSSL::X509::Certificate.new(File.read(cfg.dig('dvca_tls', 'cert')))
    tls_key = OpenSSL::PKey.read(File.open(cfg.dig('dvca_tls', 'key')))
    cfg['client_cert'] = tls_cert.to_pem.gsub(/-{5}.+-{5}/, '').gsub("\n", '')
    cfg['client_key'] = tls_key.to_pem.gsub(/-{5}.+-{5}/, '').gsub("\n", '')
   
    saml_signing_cert = OpenSSL::X509::Certificate.new(File.read(cfg.dig('saml_signing', 'cert')))
    saml_signing_key = OpenSSL::PKey.read(File.open(cfg.dig('saml_signing', 'key')))
    @saml_signing_p12 = OpenSSL::PKCS12.create(cfg['ks_password'], 'saml_signing', saml_signing_key, saml_signing_cert)

    saml_crypt_cert = OpenSSL::X509::Certificate.new(File.read(cfg.dig('saml_crypt', 'cert')))
    saml_crypt_key = OpenSSL::PKey.read(File.open(cfg.dig('saml_crypt', 'key')))
    @saml_crypt_p12 = OpenSSL::PKCS12.create(cfg['ks_password'], 'saml_crypt', saml_crypt_key, saml_crypt_cert)
  end

  puts("Output to #{OUTPUT_DIR}")

  if File.directory?(OUTPUT_DIR)
    puts("Warning: #{OUTPUT_DIR} already exists. Overwriting contents.") 
  else
    Dir.mkdir(OUTPUT_DIR)
  end

  Dir.chdir(OUTPUT_DIR) do
    # Write signing cert as DER
    File.open('connector_metadata_cert.der', 'wb') { |f| f.print(@connector_metadata_cert.to_der) }

    # Write connector metadata to file in euconfigs/
    Dir.mkdir('euconfigs') unless File.directory?('euconfigs')
    File.open(File.join('euconfigs', 'connector_metadata.xml'), 'w') { |f| f.print(@connector_metadata_raw) }
    
    # Write pkcs12 containing user-facing SSL cert and key
    File.open('ssl.p12', 'wb') { |f| f.print(@ssl_p12.to_der) }

    # Write pkcs12 containing SAML signing cert and key
    File.open('saml_signing.p12', 'wb') { |f| f.print(@saml_signing_p12.to_der) }

    # Write pkcs12 containing SAML crypt cert and key
    File.open('saml_crypt.p12', 'wb') { |f| f.print(@saml_crypt_p12.to_der) }

    # Render config templates
    render_erb('application.properties', cfg)
    render_erb('eidasmiddleware.properties', cfg)
    render_erb("POSeIDAS_#{cfg['which_dvca']}.xml", cfg, 'POSeIDAS.xml')
  end
end
